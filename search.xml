<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>article</title>
      <link href="/2022/09/10/article/"/>
      <url>/2022/09/10/article/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/09/vue-router/"/>
      <url>/2022/09/09/vue-router/</url>
      
        <content type="html"><![CDATA[<p>title: vue-router<br>date: 2022-09-10 00:10:14<br>tags:vue</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a><strong>路由</strong></h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol><li>前端路由的概念与原理</li><li>vue-router 的基本使用</li><li>vue-router 的常见用法：路由重定向、嵌套路由、动态路由、编程式导航、导航守卫</li></ol><p>##前端路由的概念与原理</p><h3 id="一、什么是路由"><a href="#一、什么是路由" class="headerlink" title="一、什么是路由"></a>一、什么是路由</h3><blockquote><p>路由（英文：router）就是对应关系。路径（地址，，，）与组件之间的的对应关系</p></blockquote><h3 id="二、什么是-SPA"><a href="#二、什么是-SPA" class="headerlink" title="二、什么是**SPA **"></a>二、什么是**SPA **</h3><blockquote><ol><li>SPA： <code>Single Page Application</code>  单页面应用程序</li><li>MPA : <code>Multiple Page Application</code>多页面应用程序</li><li>SPA 指的是一个 web 网站只有唯一的一个 HTML 页面，所有组件的展示与切换都在这唯一的一个页面内完成。此时，不同组件之间的切换需要通过前端路由来实现。</li><li>在 SPA 项目中，不同功能之间的切换，要依赖于前端路由来完成！</li></ol></blockquote><img src="单页面.png" alt="单页面" style="zoom: 25%;" /><blockquote><p>SPA优势：</p><ul><li>传统的多页面应用程序，每次请求服务器返回的都是一整个完整的页面</li><li>单页面应用程序只有第一次会加载完整的页面</li><li>以后每次请求仅仅获取必要的数据，减少了请求体积，加快页面响应速度，降低了对服务器的压力</li><li>SPA更好的用户体验，运行更加流畅</li></ul></blockquote><h3 id="三、什么是前端路由"><a href="#三、什么是前端路由" class="headerlink" title="三、什么是前端路由"></a>三、什么是前端路由</h3><blockquote><p>通俗易懂的概念：Hash 地址与组件之间的对应关系</p></blockquote><p><img src="/routes.png" alt="image-20211208173054928"></p><h3 id="四、前端路由的工作方式"><a href="#四、前端路由的工作方式" class="headerlink" title="四、前端路由的工作方式"></a>四、<strong>前端路由的工作方式</strong></h3><blockquote><ol><li>用户点击了页面上的路由链接</li><li>导致了 URL 地址栏中的 Hash 值发生了变化</li><li>前端路由监听了到 Hash 地址的变化</li><li>前端路由把当前 Hash 地址对应的组件渲染都浏览器</li></ol></blockquote><h2 id="vue-router-的基本用法"><a href="#vue-router-的基本用法" class="headerlink" title="vue-router 的基本用法"></a><strong>vue-router 的基本用法</strong></h2><h3 id="一、什么是vue-router"><a href="#一、什么是vue-router" class="headerlink" title="一、什么是vue-router"></a>一、什么是vue-router</h3><blockquote><ol><li><p>vue-router 是 vue.js 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目中组件的切换。</p></li><li><p>vue-router 的官方文档地址：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></p></li></ol></blockquote><h3 id="二、vue-router-安装和配置的步骤"><a href="#二、vue-router-安装和配置的步骤" class="headerlink" title="二、vue-router 安装和配置的步骤"></a>二、<strong>vue-router 安装和配置的步骤</strong></h3><blockquote><ol><li>安装 vue-router 包 </li><li>创建路由模块</li><li>导入并挂载路由模块</li><li>声明路由链接和占位符</li><li>声明路由的匹配规则</li></ol></blockquote><h4 id="1-安装vue-router包"><a href="#1-安装vue-router包" class="headerlink" title="1. 安装vue-router包"></a>1. 安装vue-router包</h4><p>在 vue2 的项目中，安装 vue-router 的命令如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i vue-router@<span class="number">3.5</span><span class="number">.2</span> -S</span><br></pre></td></tr></table></figure><h4 id="2-创建路由模块"><a href="#2-创建路由模块" class="headerlink" title="2. 创建路由模块"></a>2. 创建路由模块</h4><p>在 src 源代码目录下，新建 router&#x2F;index.js 路由模块，并初始化如下的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/router/index.js就是当前项目的路由模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.导入Vue和VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.调用Vue.use()函数，把VueRouter安装为Vue的插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建路由的实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.向外共享路由的实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><h4 id="3-导入并挂载路由模块"><a href="#3-导入并挂载路由模块" class="headerlink" title="3.导入并挂载路由模块"></a>3.<strong>导入并挂载路由模块</strong></h4><p>在 src&#x2F;main.js 入口文件中，导入并挂载路由模块。示例代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">main.<span class="property">js</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入路由模块，目的：拿到路由的实例对象</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">    <span class="comment">//在vue项目中，想要把路由用起来，必须把路由实例对象，通过下面的方式挂载</span></span><br><span class="line">    <span class="comment">//router：路由的实例对象</span></span><br><span class="line">    <span class="attr">router</span>: router</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="4-声明路由链接和占位符"><a href="#4-声明路由链接和占位符" class="headerlink" title="4. 声明路由链接和占位符"></a>4. 声明路由链接和占位符</h4><p>在 src&#x2F;App.vue 组件中，使用 vue-router 提供的 <router-link> 和 <router-view> 声明路由链接和占位符：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>App 根组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 使用router-link 代替a超链接--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie&quot;</span>&gt;</span>电影<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 只要在项目中安装和配置了vue-router 就可以使用router-view这个组件了 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 它的作用很单纯，占位符 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="5-声明路由的匹配规则"><a href="#5-声明路由的匹配规则" class="headerlink" title="5.声明路由的匹配规则"></a>5.声明路由的匹配规则</h4><p>在 src&#x2F;router&#x2F;index.js 路由模块中，通过 routes 数组声明路由的匹配规则。示例代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入需要使用路由切换展示的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Movie</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Movie.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;./components/About.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="comment">//routes是一个数组，作用：定义“hash地址”与“组件”之间的对应关系</span></span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/movie&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vue-router-的常见用法"><a href="#vue-router-的常见用法" class="headerlink" title="vue-router 的常见用法"></a>vue-router 的常见用法</h2><h3 id="一、路由重定向"><a href="#一、路由重定向" class="headerlink" title="一、路由重定向"></a>一、路由重定向</h3><p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C ，从而展示特定的组件页面。</p><p>通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="comment">//在routes数组中，声明路由的匹配规则</span></span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">        <span class="comment">//当用户访问 / 的时候，通过redirect属性跳转到/home对应的路由规则</span></span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/movie&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="二、嵌套路由"><a href="#二、嵌套路由" class="headerlink" title="二、嵌套路由"></a>二、嵌套路由</h3><p>通过路由实现组件的嵌套展示，叫做嵌套路由。</p><p><img src="1.png" alt="1" style="zoom:50%;" />  <img src="2.png" alt="2" style="zoom:50%;" /></p><h4 id="1-声明子路由链接和子路由占位符"><a href="#1-声明子路由链接和子路由占位符" class="headerlink" title="1. 声明子路由链接和子路由占位符"></a>1. 声明子路由链接和子路由占位符</h4><p>在 About.vue 组件中，声明 tab1 和 tab2 的子路由链接以及子路由占位符。示例代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">Habout-containern</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">h3</span>&gt;</span>About 组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- 1.在关于页面中，声明两个子路由链接--&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about/tab1&quot;</span>&gt;</span>tab1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about/tab2&quot;</span>&gt;</span>tab2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="comment">&lt;!-- 2.在关于页面中，声明子路由的占位符--&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="2-通过children属性声明子路由规则"><a href="#2-通过children属性声明子路由规则" class="headerlink" title="2.通过children属性声明子路由规则"></a>2.通过children属性声明子路由规则</h4><p>在src&#x2F;router&#x2F;index.js路由模块中，导入需要的组件，并使用children属性声明子路由规则:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Tab1</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/tabs/Tabl.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Tab2</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/tabs/Tab2.vue</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const router = new VueRouter(&#123;</span></span><br><span class="line"><span class="string">routes:[</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">//about页面的路由规则（父路由规则）</span></span><br><span class="line"><span class="string">path:&#x27;</span>/about<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">component:About,</span></span><br><span class="line"><span class="string">children:[//1.通过children属性，嵌套声明子级路由规则</span></span><br><span class="line"><span class="string">&#123;path:&#x27;</span>tab1<span class="string">&#x27;,component:Tab1&#125;,// 2.访问 /about/tab1 时，展示Tab1 组件</span></span><br><span class="line"><span class="string">&#123;path:&#x27;</span>tab2<span class="string">&#x27;,component:Tab2&#125;// 3.访问 /about/tab2 时，展示Tab2 组件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="三、动态路由"><a href="#三、动态路由" class="headerlink" title="三、动态路由"></a>三、动态路由</h3><p>思考：有如下3个路由链接:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/movie/1&quot;&gt;电影1&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/movie/2&quot;&gt;电影2&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/movie/3&quot;&gt;电影3&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>定义如下3个路由规则，是否可行???</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/movie/1&#x27;</span>,<span class="attr">component</span>:<span class="title class_">Movie</span>&#125;</span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/movie/2&#x27;</span>,<span class="attr">component</span>:<span class="title class_">Movie</span>&#125;</span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/movie/3&#x27;</span>,<span class="attr">component</span>:<span class="title class_">Movie</span>&#125;</span><br></pre></td></tr></table></figure><p>缺点：路由规则的复用性差</p><h4 id="1-动态路由的概念"><a href="#1-动态路由的概念" class="headerlink" title="1.动态路由的概念"></a>1.动态路由的概念</h4><p>动态路由指的是：把 Hash 地址中可变的部分定义为参数项，从而提高路由规则的复用性。 </p><p>在 vue-router 中使用英文的冒号（**:**）来定义路由的参数项。示例代码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//路由中的动态参数以：进行声明，冒号后面的是动态参数的名称</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/movie/:id&#x27;</span>,<span class="attr">component</span>:<span class="title class_">Movie</span>&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//将以下3个路由规则，合并成了一个，提高了路由规则的复用性</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/movie/1&#x27;</span>,<span class="attr">component</span>:<span class="title class_">Movie</span>&#125;</span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/movie/2&#x27;</span>,<span class="attr">component</span>:<span class="title class_">Movie</span>&#125;</span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/movie/3&#x27;</span>,<span class="attr">component</span>:<span class="title class_">Movie</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="2-route-params-参数对象"><a href="#2-route-params-参数对象" class="headerlink" title="2. $route.params 参数对象"></a>2. <strong>$route.params</strong> <strong>参数对象</strong></h4><p>在动态路由渲染出来的组件中，可以使用 this.$route.params 对象访问到动态匹配的参数值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;movie-container&quot;&gt;</span><br><span class="line">    &lt;!-- this.$route 是路由的“参数对象” --&gt;</span><br><span class="line">    &lt;!-- this.$router 是路由的“导航对象” --&gt;</span><br><span class="line">    &lt;h3&gt;Movie 组件 --- &#123;&#123; $route.params.mid &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Movie&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="3-route-params-参数对象"><a href="#3-route-params-参数对象" class="headerlink" title="3. $route.params 参数对象"></a>3. <strong>$route.params</strong> <strong>参数对象</strong></h4><p>为了简化路由参数的获取形式，vue-router 允许在路由规则中开启 props 传参。示例代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在定义路由规则时，声明props:true选项</span></span><br><span class="line"><span class="comment">// 即可在Movie组件中，以props的形式接收到路由规则匹配到的数据项</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/movie/:mid&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Movie</span>, <span class="attr">props</span>: <span class="literal">true</span> &#125;,</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;movie-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 直接使用props中接收的路由参数 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Movie 组件 --- &#123;&#123; mid &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;Movie&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 接收 props 数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: [<span class="string">&#x27;mid&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四-、声明式导航-amp-编程式导航"><a href="#四-、声明式导航-amp-编程式导航" class="headerlink" title="四 、声明式导航 &amp; 编程式导航"></a>四 、<strong>声明式导航 &amp; 编程式导航</strong></h3><blockquote><p>在浏览器中，点击链接实现导航的方式，叫做声明式导航。例如：</p><p>普通网页中点击 <a> 链接、vue 项目中点击 <router-link> 都属于声明式导航</p></blockquote><blockquote><p>在浏览器中，调用 API 方法实现导航的方式，叫做编程式导航。例如：</p><p>普通网页中调用 location.href 跳转到新页面的方式，属于编程式导航</p></blockquote><h4 id="1-vue-router-中的编程式导航API"><a href="#1-vue-router-中的编程式导航API" class="headerlink" title="1.  vue-router 中的编程式导航API"></a>1.  <strong>vue-router 中的编程式导航API</strong></h4><p>vue-router 提供了许多编程式导航的 API，其中最常用的导航 API 分别是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跳转到指定 hash 地址，并增加一条历史记录</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;hash 地址&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳转到指定的 hash 地址，并替换掉当前的历史记录</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(<span class="string">&#x27;hash 地址&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">//实现导航历史前进、后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(数值n)</span><br></pre></td></tr></table></figure><h4 id="2-router-push"><a href="#2-router-push" class="headerlink" title="2. $router.push()"></a>2. $router.push()</h4><p>调用 this.$router.push() 方法，可以跳转到指定的 hash 地址，从而展示对应的组件页面。示例代码如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home-container&quot;&gt;</span><br><span class="line">    &lt;h3&gt;Home 组件&lt;/h3&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;button @click=&quot;gotoMovie&quot;&gt;跳转到Movie页面&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    gotoMovie() &#123;</span><br><span class="line">      // 通过编程式导航 API，导航跳转到指定的页面</span><br><span class="line">      this.$router.push(&#x27;/movie/1&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="3-router-replace"><a href="#3-router-replace" class="headerlink" title="3. $router.replace()"></a>3. $router.replace()</h4><blockquote><p>调用 this.$router.replace() 方法，可以跳转到指定的 hash 地址，从而展示对应的组件页面。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">push 和 replace 的区别：</span><br><span class="line"><span class="number">1.</span> push 会增加一条历史记录</span><br><span class="line"><span class="number">2.</span> replace 不会增加历史记录，而是替换掉当前的历史记录</span><br></pre></td></tr></table></figure><h4 id="4-router-go"><a href="#4-router-go" class="headerlink" title="4.$router.go()"></a>4.$router.go()</h4><p>调用 this.$router.go() 方法，可以在浏览历史中前进和后退。示例代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;movie-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;goback&quot;</span>&gt;</span>后退<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: [<span class="string">&#x27;mid&#x27;</span>],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">goback</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// go(-1) 表示后退一层</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 如果后退的层数超过上限，则原地不动</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(-<span class="number">1</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="5-router-go-的简化用法"><a href="#5-router-go-的简化用法" class="headerlink" title="5. $router.go() 的简化用法"></a>5. $router.go() <strong>的简化用法</strong></h4><p>在实际开发中，一般只会前进和后退一层页面。因此 vue-router 提供了如下两个便捷方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在历史记录中，后退到上一个页面</span></span><br><span class="line"><span class="comment">// $router.back()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在历史记录中，前进到下一个页面</span></span><br><span class="line"><span class="comment">//$router.forward()</span></span><br></pre></td></tr></table></figure><h3 id="五-导航守卫（拦截器）"><a href="#五-导航守卫（拦截器）" class="headerlink" title="五 导航守卫（拦截器）"></a>五 导航守卫（拦截器）</h3><p>导航守卫可以控制路由的访问权限。示意图如下：</p><p>（1）未登录的情况下，访问后台主页</p><p><img src="/3.png" alt="image-20211208172110395"></p><p>（2）强制跳转到登录页</p><p><img src="/4.png" alt="image-20211208172216653"></p><h4 id="1-全局前置守卫"><a href="#1-全局前置守卫" class="headerlink" title="1. 全局前置守卫"></a>1. 全局前置守卫</h4><p>每次发生路由的导航跳转时，都会触发全局前置守卫。因此，在全局前置守卫中，程序员可以对每个路由进行 访问权限的控制：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建路由实例对象</span></span><br><span class="line"> <span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123; … &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//调用路由实例对象的beforeEach方法，即可声明“全局前置守卫〃</span></span><br><span class="line"> <span class="comment">//每次发生路由导航跳转的时候，都会自动触发fn这个“回调函数&quot;</span></span><br><span class="line"> router.<span class="title function_">beforeEach</span>(fn)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全局前置守卫的回调函数中接收3个形参，格式为:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建路由实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局前置守卫</span></span><br><span class="line"> router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// to是将要访问的路由的信息对象</span></span><br><span class="line"><span class="comment">// from是将要离开的路由的信息对象</span></span><br><span class="line"><span class="comment">// next是一个函数，调用next()表示放行，允许这次路由导航</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-next函数的3种调用方式"><a href="#2-next函数的3种调用方式" class="headerlink" title="2. next函数的3种调用方式"></a>2. next函数的3种调用方式</h4><p>参考示意图，分析next函数的3种调用方式最终导致的结果</p><p><img src="/5.png" alt="image-20211208172547647"></p><blockquote><p>当前用户拥有后台主页的访问权限，直接放行：next()</p><p>当前用户没有后台主页的访问权限，强制其跳转到登录页面：next(‘&#x2F;login’)</p><p>当前用户没有后台主页的访问权限，不允许跳转到后台主页：next(false)</p></blockquote><h4 id="3-控制后台主页的访问权限"><a href="#3-控制后台主页的访问权限" class="headerlink" title="3. 控制后台主页的访问权限"></a><strong>3. 控制后台主页的访问权限</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/main&#x27;</span>) &#123;</span><br><span class="line">     <span class="comment">//设置token值</span></span><br><span class="line">     localstorage.<span class="title function_">setltem</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">     <span class="comment">//移除token值</span></span><br><span class="line">     localstorage.<span class="title function_">removeItem</span>(<span class="string">&#x27;age&#x27;</span>,<span class="number">18</span>)</span><br><span class="line">     </span><br><span class="line"><span class="keyword">const</span> token = localstorage.<span class="title function_">getltem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">     <span class="keyword">if</span> (token) &#123;</span><br><span class="line">     <span class="title function_">next</span>() <span class="comment">//访冋的是后台主页，且有token的值</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>) <span class="comment">//访问的是后台主页，但是没有token的值</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="title function_">next</span>() <span class="comment">//访问的不是后台主页，直接放行</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/09/Vue-%E7%BB%84%E4%BB%B6/"/>
      <url>/2022/09/09/Vue-%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>title: Vue组件化<br>date: 2022-09-10 00:10:14<br>tags:vue</p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>组件的定义————实现应用中局部功能代码和资源的集合</p><p><em><strong>组件就是一块砖，哪里需要哪里搬</strong></em></p><h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><blockquote><p>组件化开发指的是：根据封装的思想，把页面上可重用的 UI 结构封装为组件，从而方便项目的开发和维护</p><p>vue 是一个支持组件化开发的前端框架。 vue 中规定：组件的后缀名是 .vue。之前接触到的 App.vue 文件本质上就是一个 vue 的组件</p></blockquote><h2 id="一、vue组件组成"><a href="#一、vue组件组成" class="headerlink" title="一、vue组件组成"></a>一、vue组件组成</h2><p> 每个 .vue 组件都由 3 部分构成，分别是： </p><ol><li><p>template -&gt; 组件的模板结构 </p></li><li><p>script -&gt; 组件的 JavaScript 行为 </p></li><li><p>style -&gt; 组件的样式 其中，每个组件中必须包含 template 模板结构，而 script 行为和 style 样式是可选的组成部分</p></li></ol><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p>vue 规定：每个组件对应的模板结构，需要定义到 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;!--当前组件的DOM结构，需要定义到template标签中--&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><ol><li>template 是 vue 提供的容器标签，只起到包裹性质的作用，它不会被渲染为真正的 DOM 元素</li><li>template中只能包含唯一的根节点</li></ol></blockquote><h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>vue 规定：开发者可以在<script>节点中封装组件的JavaScript业务逻辑</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> //今后，组件相关的data数据，methods方法等都需要定义到export default所导出的对象中</span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>vue 规定：.vue 组件中的 data 必须是一个函数，不能直接指向一个数据对象。</p><p>因此在组件中定义 data 数据节点时，下面的方式是错误的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>:&#123;<span class="comment">//组件中，不能让data指向一个数据对象（会报错）&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/components.html#data">报错原因</a></p><h3 id="style"><a href="#style" class="headerlink" title="style"></a>style</h3><p>vue 规定：组件内的<style>节点是可选的，开发者可以在<style>节点中编写样式美化当前组件的UI结构。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;style lang=<span class="string">&quot;scoped&quot;</span>&gt;</span><br><span class="line">h1&#123;</span><br><span class="line">    font-<span class="attr">weight</span>:normal;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="二、组件基本使用"><a href="#二、组件基本使用" class="headerlink" title="二、组件基本使用"></a>二、组件基本使用</h2><blockquote><ol><li>组件在被封装好之后，彼此之间是相互独立的，不存在父子关系</li><li>在使用组件的时候，根据彼此的嵌套关系，形成了父子关系、兄弟关系</li></ol></blockquote><h3 id="私有组件"><a href="#私有组件" class="headerlink" title="私有组件"></a>私有组件</h3><p>使用步骤示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">App.vue组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app-container&quot;&gt;</span><br><span class="line">      &lt;!--步骤3：以标签形式使用刚才注册的组件 --&gt;</span><br><span class="line">      &lt;Left&gt;&lt;/Left&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 步骤1：使用 import 语法导入需要的组件</span><br><span class="line">    import Left from &#x27;@/components/Left.vue&#x27;;</span><br><span class="line"></span><br><span class="line">    export default &#123;</span><br><span class="line">      //步骤2：使用 components 节点注册组件</span><br><span class="line">      components:&#123;</span><br><span class="line">        Left,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>路径提示插件： Path Autocomplete </p><p>在settings.json中配置：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入文件时是否携带文件的扩展名</span></span><br><span class="line"><span class="attr">&quot;path-autocomplete.extensionOnImport&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"> <span class="comment">//配置@的路径提示</span></span><br><span class="line"><span class="attr">&quot;path-autocomplete.pathMappings&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;@/&quot;</span><span class="punctuation">:</span><span class="string">&quot;$&#123;folder&#125;/src/&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p>需求：在Left和Right组件中均需要使用Common组件</p><p>解决办法：在 vue 项目的 main.js 入口文件中，通过 Vue.component() 方法，可以注册全局组件。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Common.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Common组件</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">main.<span class="property">js</span></span><br><span class="line"><span class="comment">//导入需要全局注册的组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Common</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Common.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数1：字符串格式，表示组件的“注册名称”</span></span><br><span class="line"><span class="comment">//参数2：需要被全局注册的那个组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyCommon&#x27;</span>,<span class="title class_">Common</span>)</span><br></pre></td></tr></table></figure><h3 id="组件的props自定义属性"><a href="#组件的props自定义属性" class="headerlink" title="组件的props自定义属性"></a>组件的props自定义属性</h3><p>需求：Left组件和Right组件上显示count初始值要求不一样？？？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Common.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h5&gt;Common组件&lt;/h5&gt;</span><br><span class="line">    &lt;p&gt;count的值是：&#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;count+=1&quot;&gt;+1&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        count:0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>解决办法：props自定义属性</p><p>props 是组件的自定义属性，在封装通用组件的时候，合理地使用 props 可以极大的提高组件的复用性！语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  //组件的自定义属性</span><br><span class="line">  props:[&#x27;自定义属性A&#x27;,&#x27;自定义属性B&#x27;,&#x27;自定义属性....&#x27;],</span><br><span class="line">  //组件的私有数据</span><br><span class="line">  data()&#123;</span><br><span class="line">  return &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Common.vue</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    //props是自定义属性，允许使用者通过自定义属性，为当前组件指定初始值</span><br><span class="line">    //自定义属性的名字，是封装者自定义的（只要名称合法即可）</span><br><span class="line">    //props中的数据，可以直接在模板结构中被使用</span><br><span class="line">    props:[&#x27;init&#x27;],</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        count:0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">Left.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;left-container&quot;&gt;</span><br><span class="line">    &lt;h3&gt;Left 组件&lt;/h3&gt;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    &lt;Common :init=&quot;9&quot;&gt;&lt;/Common&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="props只读"><a href="#props只读" class="headerlink" title="props只读"></a>props只读</h4><blockquote><ol><li>vue 规定：组件中封装的自定义属性是只读的，程序员不能直接修改 props 的值。否则会直接报错.</li><li>要想修改 props 的值，可以把 props 的值转存到 data 中，因为 data 中的数据都是可读可写的！</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Common.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h5&gt;Common组件&lt;/h5&gt;</span><br><span class="line">    &lt;p&gt;count的值是：&#123;&#123;count&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;count+=1&quot;&gt;+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;show&quot;&gt;       </span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    //注意props是只读的，不要直接修改props的值，否则终端会报错！</span><br><span class="line">    props:[&#x27;init&#x27;],</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        count:this.init</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        show()&#123;</span><br><span class="line">            console.log(this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a><strong>mixin(混入)</strong></h3><ol><li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p></li><li><p>使用方式：</p></li></ol><p>第一步定义混合：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hunhe=&#123;</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">showName</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你好啊&#x27;</span>);</span><br><span class="line">     &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hunhe2=&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">x</span>:<span class="number">100</span>,</span><br><span class="line">            <span class="attr">y</span>:<span class="number">200</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第二步使用混入：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部混入</span></span><br><span class="line"><span class="keyword">import</span> &#123;hunhe,hunhe2&#125; <span class="keyword">from</span> <span class="string">&#x27;./mixin&#x27;</span> </span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;Student&#x27;</span>,</span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>&#123;</span><br><span class="line">                <span class="attr">name</span>:<span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">                <span class="attr">address</span>:<span class="string">&#x27;北京&#x27;</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">          <span class="attr">mixins</span>:[hunhe,hunhe2]</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局混入</span></span><br><span class="line">main.<span class="property">js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;hunhe, hunhe2&#125; <span class="keyword">from</span> <span class="string">&#x27;./mixin&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(hunhe)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(hunhe2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   全局混入：<code>Vue.mixin(xxx)</code></p><p>   局部混入：<code>mixins:[&#39;xxx&#39;]  </code></p><h3 id="组件之间的样式冲突"><a href="#组件之间的样式冲突" class="headerlink" title="组件之间的样式冲突"></a>组件之间的样式冲突</h3><p>默认情况下，写在 .vue 组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。导致组件之间样式冲突的根本原因是：</p><blockquote><ol><li>单页面应用程序中，所有组件的 DOM 结构，都是基于唯一的 index.html 页面进行呈现的</li><li>每个组件中的样式，都会影响整个 index.html 页面中的 DOM 元素</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Left.vue组件中的样式，全局生效</span><br><span class="line"></span><br><span class="line">h3&#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何解决样式冲突问题"><a href="#如何解决样式冲突问题" class="headerlink" title="如何解决样式冲突问题"></a>如何解决样式冲突问题</h4><p>为每个组件分配唯一的自定义属性，在编写组件样式时，通过属性选择器来控制样式的作用域，示例代码如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">left</span><span class="selector-class">.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">left</span>-container&quot; data-v-<span class="number">001</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">h3</span> data-v-<span class="number">001</span>&gt;<span class="attribute">Left</span> 组件&lt;/<span class="selector-tag">h3</span>&gt;</span><br><span class="line">    &lt;hr data-v-<span class="number">001</span>/&gt;</span><br><span class="line">    &lt;Common :init=<span class="string">&quot;9&quot;</span> data-v-<span class="number">001</span>&gt;&lt;/Common&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">h3[data-v-<span class="number">001</span>]&#123;</span><br><span class="line">  <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="scoped属性"><a href="#scoped属性" class="headerlink" title="scoped属性"></a>scoped属性</h4><p>为了提高开发效率和开发体验，vue 为 style 节点提供了 scoped 属性，从而防止组件之间的样式冲突问题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">h3&#123;</span><br><span class="line">  color:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="deep"><a href="#deep" class="headerlink" title="/deep/"></a>/deep/</h4><p>如果给当前组件的 style 节点添加了 scoped 属性，则当前组件的样式对其子组件是不生效的。如果想让某些样式对子组件生效，可以使用 /deep/ 深度选择器</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 在父组件中改变子组件中的样式</span><br><span class="line">/deep/ <span class="selector-tag">h5</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vue项目运行原理深层分析</p><ol><li>浏览器不能执行vue文件，由vue-template-compiler把vue文件编译成js交给浏览器。</li><li>Common.vue 可以理解为就是一个构造函数，使用组件<Common></Common>的过程就是new 组件实例的过程。</li></ol><h3 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h3><ol><li>被用来给元素或子组件注册引用信息（id的替代者）</li><li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li><li>使用方式：<ol><li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li><li>获取：<code>this.$refs.xxx</code></li></ol></li></ol><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ol><li><p>功能：用于增强Vue</p></li><li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p></li><li><p>定义插件：</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line"></span><br><span class="line">​    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(....)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 2. 添加全局指令</span></span><br><span class="line"></span><br><span class="line">​    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(....)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line"></span><br><span class="line">​    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(....)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line"></span><br><span class="line">​    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">​    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用插件：<code>Vue.use()</code></li></ol><h2 id="三、组件之间的数据共享"><a href="#三、组件之间的数据共享" class="headerlink" title="三、组件之间的数据共享"></a>三、组件之间的数据共享</h2><p>在项目开发中，组件之间的最常见的关系分为如下两种： </p><ol><li><p>父子关系</p></li><li><p>非父子关系</p></li></ol><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>父组件向子组件共享数据需要使用<strong>自定义属性</strong>。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Father.vue</span><br><span class="line">&lt;Son :msg=&quot;message&quot; :user=&quot;userinfo&quot;&gt;&lt;/Son&gt;</span><br><span class="line"></span><br><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        message:&#x27;hello vue.js&#x27;,</span><br><span class="line">        userinfo:&#123;</span><br><span class="line">            name:&#x27;zs&#x27;,</span><br><span class="line">            age:20</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Son.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h5&gt;Son组件&lt;/h5&gt;</span><br><span class="line">&lt;p&gt;父组件传递过来msg的值是：&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;父组件传递过来user的值是：&#123;&#123;user&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">//不要去修改props值</span><br><span class="line">props:[&#x27;msg&#x27;,&#x27;user&#x27;]</span><br></pre></td></tr></table></figure><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>子组件向父组件共享数据使用<strong>自定义事件</strong>。示例代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Son</span>.<span class="property">vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Right 组件-----&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line"><span class="title function_">add</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">count</span> +=<span class="number">1</span></span><br><span class="line"><span class="comment">//修改数据时，通过$emit触发自定义事件</span></span><br><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;numchange&#x27;</span>,<span class="variable language_">this</span>.<span class="property">count</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Father</span>.<span class="property">vue</span></span><br><span class="line">&lt;<span class="title class_">Son</span> @numchange=<span class="string">&quot;getNewCount&quot;</span>&gt;&lt;/<span class="title class_">Son</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">countFromSon</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line"><span class="title function_">getNewCount</span>(<span class="params">val</span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">countFromSon</span> = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h3><ol><li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===> 父组件</strong></p></li><li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p></li><li><p>绑定自定义事件：</p><ol><li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p></li><li><p>第二种方式，在父组件中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">&quot;demo&quot;</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">xxx</span>.$on(<span class="string">&#x27;atguigu&#x27;</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p></li></ol></li><li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code></p></li><li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p></li><li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p></li><li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p></li></ol><h3 id="非父子：事件总线EventBus"><a href="#非父子：事件总线EventBus" class="headerlink" title="非父子：事件总线EventBus"></a>非父子：事件总线EventBus</h3><p>在 vue2.x 中，兄弟组件之间数据共享的方案是 EventBus。</p><p>适用于<span style="color:red">任意组件间通信</span>。</p><p>EventBus的使用步骤</p><blockquote><ol><li>创建 eventBus.js 模块，并向外共享一个 Vue 的实例对象</li><li>在数据发送方，调用 bus.$emit('事件名称', 要发送的数据) 方法触发自定义事件</li><li>在数据接收方，调用 bus.$on('事件名称', 事件处理函数) 方法注册一个自定义事件</li></ol></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eventBus.<span class="property">js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向外共享Vue实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">组件A发送方</span><br><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">&#x27;./eventBus.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">msg</span>:<span class="string">&#x27;hello vue.js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line"><span class="title function_">sendMsg</span>(<span class="params"></span>)&#123;</span><br><span class="line">bus.$emit(<span class="string">&#x27;share&#x27;</span>,<span class="variable language_">this</span>.<span class="property">msg</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">组件B接收方</span><br><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">&#x27;./eventBus.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">msgFromLeft</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">bus.$on(<span class="string">&#x27;share&#x27;</span>,<span class="function"><span class="params">val</span>=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">msgFromLeft</span> = val;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：</p><ol><li><p>安装全局事件总线：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p></li></ol></li><li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeDestroy</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">$bus</span>.$off(<span class="string">&#x27;XXX&#x27;</span>)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h3><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>使用步骤：</p><ol><li><p>安装pubsub：<code>npm i pubsub-js</code></p></li><li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p></li><li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>) <span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pubId</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="function">(<span class="params">msgName,data</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//console.log(&#x27;this&#x27;); undefind</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;有人发布了hello消息，hello消息的回调执行了&#x27;</span>,msgName,data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p></li><li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p></li></ol></li></ol><h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h1><ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li><li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li></ol><h1 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h1><ol><li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p></li><li><p>图示：<img src="C:\Users\26043\AppData\Roaming\Typora\typora-user-images\image-20220622133120855.png" alt="image-20220622133120855"></p></li><li><p>写法：</p><ol><li><p>准备好样式：</p><ul><li>元素进入的样式：<ol><li>v-enter：进入的起点</li><li>v-enter-active：进入过程中</li><li>v-enter-to：进入的终点</li></ol></li><li>元素离开的样式：<ol><li>v-leave：离开的起点</li><li>v-leave-active：离开过程中</li><li>v-leave-to：离开的终点</li></ol></li></ul></li><li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class="line">&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></li><li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p></li></ol></li></ol><h1 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h1><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​在vue.config.js中添加如下配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:<span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li><li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li><li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​编写vue.config.js配置具体代理规则：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">      <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api1&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">         <span class="attr">ws</span>: <span class="literal">true</span>, <span class="comment">//用于支持websocket</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/api2&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">        <span class="attr">ws</span>: <span class="literal">true</span>, <span class="comment">//用于支持websocket</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li><li>缺点：配置略微繁琐，请求资源时必须加前缀。</li></ol><h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><ol><li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===> 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>具名插槽：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>作用域插槽：</p><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是ul列表 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是h4标题 --&gt;</span><br><span class="line">&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            export default &#123;</span><br><span class="line">                name:&#x27;Category&#x27;,</span><br><span class="line">                props:[&#x27;title&#x27;],</span><br><span class="line">                //数据在子组件自身</span><br><span class="line">                data() &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h1 id="生命周期与生命周期函数"><a href="#生命周期与生命周期函数" class="headerlink" title="生命周期与生命周期函数"></a>生命周期与生命周期函数</h1><h2 id="生命周期-生命周期函数"><a href="#生命周期-生命周期函数" class="headerlink" title="生命周期&生命周期函数"></a>生命周期&生命周期函数</h2><ul><li>生命周期（Life Cycle）是指一个组件从创建 -> 运行 -> 销毁（创建==>挂载==》更新==》销毁）的整个阶段，强调的是一个时间段。</li><li>生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行</li></ul><blockquote><ol><li>组件创建阶段：beforeCreate()、created()、挂载阶段：beforeMount()、Mounted()</li><li>组件运行（更新）阶段：beforeUpdate()、Updated()</li><li>组件销毁阶段：beforeDestroy()、Destroyed()</li></ol></blockquote><ul><li>注意：生命周期强调的是时间段，生命周期函数强调的是时间点。</li><li><a href="https://cn.vuejs.org/v2/guide/instance.html">生命周期图示</a></li></ul><p><img src="E:\vue笔记资料\代码资料\资料（含课件）\02_原理图\生命周期.png" alt="生命周期"></p><p>一个Vue组件本质上也是一个vue实例</p><h2 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate()"></a>beforeCreate()</h2><ul><li>说明：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</li><li>注意：组件的props/data/methods尚未被创建，都处于不可用状态</li><li>不常用</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;Test组件&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props:[&#x27;info&#x27;],</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message:&#x27;hello vue.js&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    show()&#123;</span><br><span class="line">      console.log(&#x27;调用了Test组件的show方法!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  //创建阶段的第1个生命周期函数</span><br><span class="line">  beforeCreate()&#123;</span><br><span class="line">    console.log(this.info);//报错</span><br><span class="line">    console.log(this.message);//undefined</span><br><span class="line">    this.show();//报错</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="created"><a href="#created" class="headerlink" title="created()"></a><strong>created()</strong></h2><ul><li>注意：组件的props/data/methods已创建好，都处于可用的状态，但是组件的模板结构尚未生成！</li><li>注意：这是一个常用的生命周期函数，可以调用methods中的方法、改变data中的数据</li><li><a href="https://segmentfault.com/a/1190000008879966">vue实例生命周期 参考1</a></li><li><a href="https://segmentfault.com/a/1190000008010666">vue实例生命周期 参考2</a></li><li>使用场景：<strong>发送ajax请求获取数据</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Test组件---&#123;&#123;books.length&#125;&#125;本图书<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>:[<span class="string">&#x27;info&#x27;</span>],</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>:<span class="string">&#x27;hello vue.js&#x27;</span>,</span><br><span class="line">      <span class="comment">//定义books数组，存储所有的图书列表数据。默认是空数组</span></span><br><span class="line">      <span class="attr">books</span>:[]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="title function_">send</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功发送ajax请求&#x27;</span>);</span><br><span class="line">      <span class="comment">//模拟接收到ajax请求回来的数据</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">booksdata</span>:[</span><br><span class="line">          &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">bookname</span>:<span class="string">&#x27;zs&#x27;</span>&#125;,</span><br><span class="line">          &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">bookname</span>:<span class="string">&#x27;ll&#x27;</span>&#125;,</span><br><span class="line">          &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">bookname</span>:<span class="string">&#x27;ww&#x27;</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//created生命周期函数，非常常用</span></span><br><span class="line">  <span class="comment">//经常在它里面，调用methods中的方法，请求服务器数据</span></span><br><span class="line">  <span class="comment">//并且把请求到的数据，转存到data中，供template模板渲染的时候使用</span></span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="variable language_">this</span>.<span class="title function_">send</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">books</span> = res.<span class="property">booksdata</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount()"></a>beforeMount()</h2><ul><li>说明：将要把内存中编译好的HTML结构渲染到浏览器中。此时浏览器中还没有当前组件的DOM结构</li><li>不常用</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> dom = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#myh3&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(dom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted()"></a><strong>mounted()</strong></h2><ul><li>说明：已经把内存中的HTML结构，成功的渲染到了浏览器之中。此时，浏览器中已然包含了当前组件的DOM结构。就是Vue完成模板解析并把初始的真实的DOM元素放入页面后（挂载完毕）调用mounted</li><li>mounted( )，第一次把DOM结构渲染好</li><li>生命周期函数中的this指向是vm 或者 组件实例对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果要操作当前组件的DOM，最早可以在mounted()阶段中进行</span></span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#myh3&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dom);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>运行阶段的钩子函数最少执行0次，最多执行N次</strong></p><h2 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate()"></a>beforeUpdate()</h2><ul><li>说明：<strong>将要</strong>根据变化过后，最新的数据，重新渲染组件的模板结构</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;dddd&quot;</span>&gt;</span>message的值是：&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;message+=&#x27;~&#x27;&quot;</span>&gt;</span>修改message的值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">beforeUpdate</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>);<span class="comment">//数据最新</span></span><br><span class="line">    <span class="comment">//页面还没有来得及更新</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#dddd&#x27;</span>).<span class="property">innerHTML</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="updated"><a href="#updated" class="headerlink" title="updated()"></a>updated()</h2><ul><li>说明：已经根据最新的数据，完成了组件DOM结构的重新渲染。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//当数据变化之后，为了能够操作得到最新的DOM结果，必须把代码写到updated()钩子函数中</span></span><br><span class="line"><span class="title function_">updated</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>);<span class="comment">//数据最新</span></span><br><span class="line">    <span class="comment">//页面还没有来得及更新</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#dddd&#x27;</span>).<span class="property">innerHTML</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>销毁阶段周期函数比较不常用</p><h2 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy()"></a>beforeDestroy()</h2><ul><li>说明：将要销毁此组件，此时尚未销毁，组件还处于正常工作的状态。</li><li>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>.<span class="property">vue</span></span><br><span class="line">&lt;h1&gt;<span class="title class_">App</span> 根组件&lt;/h1&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;flag = !flag&quot;</span>&gt;</span>销毁<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Test</span> <span class="attr">:info</span>=<span class="string">&quot;info&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;flag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Test</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Test</span>.<span class="property">vue</span></span><br><span class="line"> <span class="title function_">beforeDestroy</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeDestroy&#x27;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed()"></a>destroyed()</h2><ul><li>说明：组件已经被销毁，此组件在浏览器对应的DOM结构已被完全移除。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">destroyed</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;destroyed&#x27;</span>, <span class="string">&#x27;销毁后执行&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/09/Vue-Cli/"/>
      <url>/2022/09/09/Vue-Cli/</url>
      
        <content type="html"><![CDATA[<p>title: Vue-Cli<br>date: 2022-09-10 00:10:14<br>tags:vue</p><h3 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h3><h4 id="一、认识Nodejs"><a href="#一、认识Nodejs" class="headerlink" title="一、认识Nodejs"></a>一、认识Nodejs</h4><p>Node.js® 是一个基于 <a href="https://v8.dev/">Chrome V8 引擎</a> 的 JavaScript 运行时。</p><h5 id="1-1-宿主环境"><a href="#1-1-宿主环境" class="headerlink" title="1.1 宿主环境"></a>1.1 宿主环境</h5><p>Javascript 是由 ECMAScript、DOM、BOM 三部分组成，浏览器实现了 ECMAScript 标准，使其能够运行于浏览器，我们称浏览器为 ECMAScript 的宿主环境。</p><p>Nodejs就是另一种可以运行 ECMAScript 的宿主环境。</p><h5 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h5><p>Nodejs 开源且跨平台，在 Windows 平台，Nodejs 就是一个以 <code>.msi</code> 结尾的安装程序，分为 <a href="https://nodejs.org/dist/v12.18.3/node-v12.18.3-x86.msi">32位</a> 和 <a href="https://nodejs.org/dist/v12.18.3/node-v12.18.3-x64.msi">64位</a> 两个版本，双击运行根据引导程序完成安装即可。</p><p><a href="http://nodejs.cn/">Nodejs中文官网</a></p><p>打开 cmd 或 powershell 执行如下命令，如出现版本则为安装成功。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v;</span><br><span class="line">npm -v;</span><br></pre></td></tr></table></figure><h5 id="1-3-体验"><a href="#1-3-体验" class="headerlink" title="1.3 体验"></a>1.3 体验</h5><p>Nodejs 程序是以 <code>.js</code> 结尾的文件，创建 <code>demo.js</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x + y);</span><br></pre></td></tr></table></figure><p>打开 cmd 或 powershell 命令行工具，执行 <code>demo.js</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node path/demo.js</span><br></pre></td></tr></table></figure><p>注：Nodejs 和 JavaScript 都是基于 ECMAScript 语言规范的，二者的语法具有一致性，显著的区别是 Nodejs 中并没有 DOM 和 BOM，因此无法使用 window 或 document 相关语法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法错误</span><br><span class="line">alert(&#x27;Hello Nodejs!&#x27;); </span><br><span class="line">document.write(&#x27;你好，世界!&#x27;);</span><br></pre></td></tr></table></figure><p>注：创建文件名或者文件夹的名字一定一定一定要避免使用 node。</p><h4 id="二、NPM"><a href="#二、NPM" class="headerlink" title="二、NPM"></a>二、NPM</h4><p>Nodejs 有着庞大的社区支持，全世界优秀的开发人员封装了大量实用的模块，托管在<a href="https://www.npmjs.com/">开源平台</a>上供大家随意下载使用。</p><p>为了方便大家上传、下载开源模块，社区还开发专门的工具 <code>npm</code>，该工具随着 Nodejs 一起被安装了。</p><h5 id="2-1-NPM基本使用"><a href="#2-1-NPM基本使用" class="headerlink" title="2.1 NPM基本使用"></a>2.1 NPM基本使用</h5><blockquote><ol><li><p>NPM(Node Package Manager), node的包管理器</p></li><li><p>只要安装Node软件包，那么当前电脑中就会自带Npm包管理器</p></li><li><p>切记，为下载第三方模块更加快速，一定要将镜像源设置成国内淘宝服务器</p></li></ol></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm config set registry <span class="attr">http</span>:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line"></span><br><span class="line">查看当前镜像源：npm get registry</span><br></pre></td></tr></table></figure><h5 id="2-2-NPM常用命令"><a href="#2-2-NPM常用命令" class="headerlink" title="2.2 NPM常用命令"></a>2.2 NPM常用命令</h5><table><thead><tr><th><strong>命令</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>npm init [-y]</td><td>初始化一个package.json文件</td></tr><tr><td>npm install 包名 –save</td><td>安装一个包，会生成node_modules文件夹</td></tr><tr><td>npm install 包名 -g</td><td>安装一个全局命令行工具</td></tr><tr><td>npm install 包名 –save</td><td>将安装的包添加到package的依赖中(dependencies)</td></tr><tr><td>npm uninstall 包</td><td>卸载当前目录下某个包</td></tr><tr><td>npm uninstall 包 -g</td><td>卸载全局路径安装下的某个包</td></tr><tr><td>npm list</td><td>查看当前目录下安装的所有包</td></tr><tr><td>npm list –g</td><td>查看全局路径下安装的所有的包</td></tr></tbody></table><h5 id="2-3-NRM基本使用"><a href="#2-3-NRM基本使用" class="headerlink" title="2.3 NRM基本使用"></a>2.3 NRM基本使用</h5><p>NRM ( Node Regitry Manager )，是Npm的镜像源管理工具</p><blockquote><ol><li><p>有时候国外资源太慢，使用这个就可以快速地在npm源间切换</p></li><li><p>安装nrm： 在命令行执行命令，<strong>npm install nrm -g</strong> ，全局安装nrm</p></li><li><p>执行命令nrm ls查看可选的源</p></li><li><p>可以通过nrm test测试相应源的相应时间</p></li></ol></blockquote><h5 id="2-4-NRM基本命令"><a href="#2-4-NRM基本命令" class="headerlink" title="2.4 NRM基本命令"></a>2.4 NRM基本命令</h5><table><thead><tr><th><strong>命令</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>nrm ls</td><td>查看镜像源</td></tr><tr><td>nrm test</td><td>检测镜像源下载速度</td></tr><tr><td>nrm use</td><td>切换镜像源</td></tr><tr><td>nrm current</td><td>当前镜像源</td></tr><tr><td>nrm -h</td><td>查看nrm命令</td></tr></tbody></table><h5 id="2-5-描述性文件"><a href="#2-5-描述性文件" class="headerlink" title="2.5 描述性文件"></a>2.5 描述性文件</h5><p>若干模块组合起来放在统一目录中时推荐创建 <code>package.json</code> 文件，该文件中记录模块的名称、版本、依赖等信息，<code>package.json</code> 文件即可以手动创建，也能通过命令快速创建。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">npm init</span><br><span class="line"># 或</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><ol><li><p><code>name</code> 标记模块的名称，名称中不允许包含大写字母</p></li><li><p><code>version</code> 标记模块的版本号</p></li><li><p><code>main</code> 模块入口，默认为 <code>index.js</code></p></li><li><p><code>script</code> 自定义脚本命令，以 <code>npm run 命令名称</code> 形式调用，<code>npm run start</code> 时，可以省略 <code>run</code></p></li><li><p><code>dependencies</code> 记录所有被依赖的模块，安装模块时添加 <code>--save</code> 或 <code>-S</code> 模块会被记录在 <code>package.json</code> 中</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install lodash --save</span><br><span class="line">npm install mime -S</span><br></pre></td></tr></table></figure><ol start="6"><li><p><code>devDependencies</code> 记录开发阶段所有被依赖的模块，安装模块时添加 <code>--save-dev</code> 或 <code>-D</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install gulp --save-dev</span><br><span class="line">npm install gulp-less -D</span><br></pre></td></tr></table></figure><p>注：设置淘宝镜像可以加快模块的安装速度 npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p></li></ol><p><a href="https://www.bilibili.com/video/BV1zq4y1p7ga?p=5">webpack学习视频</a></p><h3 id="vue-cli脚手架"><a href="#vue-cli脚手架" class="headerlink" title="vue-cli脚手架"></a>vue-cli脚手架</h3><p>vue-cli 是 Vue.js 开发的标准工具。它简化了程序员基于 webpack 创建工程化的 Vue 项目的过程。</p><p>借助vue-cli工具，程序员可以专注在撰写应用上，而不必花好几天去纠结 webpack 配置的问题。</p><p><a href="%EF%BC%9Ahttps://cli.vuejs.org/zh/">中文官网</a></p><h4 id="一、安装和使用"><a href="#一、安装和使用" class="headerlink" title="一、安装和使用"></a>一、安装和使用</h4><p>vue-cli 是 npm 上的一个全局包，使用 npm install 命令，即可方便的把它安装到自己的电脑上。 </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line">vue -V</span><br></pre></td></tr></table></figure><p>基于 vue-cli 快速生成工程化的 Vue 项目</p><ol><li>基于交互命令行的方式，创建vue项目</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vue create 项目的名称</span><br><span class="line"><span class="number">1</span>）选择配置项</span><br><span class="line"><span class="number">2</span>）进入vue项目文件夹cd demo</span><br><span class="line"><span class="number">3</span>）启动项目npm run serve</span><br><span class="line"><span class="number">4</span>）在浏览器地址中输入http：<span class="comment">//localhost:8080</span></span><br></pre></td></tr></table></figure><ol start="2"><li>基于图形化界面，创建vue项目</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure><h4 id="二、vue项目中src目录构成"><a href="#二、vue项目中src目录构成" class="headerlink" title="二、vue项目中src目录构成"></a>二、vue项目中src目录构成</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assets文件夹：存放项目中用到的静态资源文件，例如：css 样式表、图片资源</span><br><span class="line">components文件夹：程序员封装的、可复用的组件，都要放到 components 目录下</span><br><span class="line">main.<span class="property">js</span> 是项目的入口文件。整个项目的运行，要先执行 main.<span class="property">js</span></span><br><span class="line"><span class="title class_">App</span>.<span class="property">vue</span> 是项目的根组件。</span><br></pre></td></tr></table></figure><h4 id="三、vue项目运行流程"><a href="#三、vue项目运行流程" class="headerlink" title="三、vue项目运行流程"></a>三、vue项目运行流程</h4><p>在工程化的项目中，vue 要做的事情很单纯：通过 main.js 把 App.vue 渲染到 index.html 的指定区域中。 其中： </p><blockquote><ol><li>App.vue 用来编写待渲染的模板结构 </li><li>index.html 中需要预留一个 el 区域 </li><li>main.js 把 App.vue 渲染到了 index.html 所预留的区域中</li></ol></blockquote><p>main.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入vue包，得到Vue构造函数</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//导入App.vue根组件，将来要把App.vue中的模板结构，渲染到html页面中</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//去除vue中警告</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Vue实例</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="comment">// 将render函数指定的组件，渲染到html页面中</span></span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>app.vue</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fz&quot;</span>&gt;</span>哈哈哈&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><h5 id="一、组件化开发"><a href="#一、组件化开发" class="headerlink" title="一、组件化开发"></a>一、组件化开发</h5><blockquote><ol><li>组件化开发指的是：根据封装的思想，把页面上可重用的 UI 结构封装为组件，从而方便项目的开发和维护</li><li>vue 是一个支持组件化开发的前端框架。 vue 中规定：组件的后缀名是 .vue。之前接触到的 App.vue 文件本质上就是一个 vue 的组件</li></ol></blockquote><h5 id="二、vue-组件三个组成部分"><a href="#二、vue-组件三个组成部分" class="headerlink" title="二、vue 组件三个组成部分"></a>二、vue 组件三个组成部分</h5><p> 每个 .vue 组件都由 3 部分构成，分别是： </p><ol><li>template -&gt; 组件的模板结构 </li><li>script -&gt; 组件的 JavaScript 行为 </li><li>style -&gt; 组件的样式 其中，每个组件中必须包含 template 模板结构，而 script 行为和 style 样式是可选的组成部分</li></ol><h6 id="template"><a href="#template" class="headerlink" title="template"></a>template</h6><p>vue 规定：每个组件对应的模板结构，需要定义到 </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;!--当前组件的<span class="variable constant_">DOM</span>结构，需要定义到template标签中--&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><ol><li>template 是 vue 提供的容器标签，只起到包裹性质的作用，它不会被渲染为真正的 DOM 元素</li><li>template中只能包含唯一的根节点</li></ol></blockquote><h6 id="script"><a href="#script" class="headerlink" title="script"></a>script</h6><p>vue 规定：开发者可以在<script>节点中封装组件的JavaScript业务逻辑</p><script>节点基本结构如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="comment">//今后，组件相关的data数据，methods方法等</span></span><br><span class="line"> <span class="comment">//都需要定义到export default所导出的对象中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>vue 规定：.vue 组件中的 data 必须是一个函数，不能直接指向一个数据对象。因此在组件中定义 data 数据节点时，下面的方式是错误的：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data:&#123;//组件中，不能让data指向一个数据对象（会报错）</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>[报错原因](https://cn.vuejs.org/v2/guide/components.html#data)###### stylevue 规定：组件内的<style>节点是可选的，开发者可以在<style>节点中编写样式美化当前组件的UI结构。<script>节点的基本结构如下<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style lang=&quot;&quot;&gt;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:normal;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/09/Vuex/"/>
      <url>/2022/09/09/Vuex/</url>
      
        <content type="html"><![CDATA[<p>title: vuex<br>date: 2022-09-10 00:10:14<br>tags:vue</p><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><ol><li>理解Vuex</li><li>vuex核心概念和API</li></ol><p>##理解Vuex</p><h3 id="一、Vuex是什么"><a href="#一、Vuex是什么" class="headerlink" title="一、Vuex是什么"></a>一、Vuex是什么</h3><blockquote><p>1.概念：专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应 </p><p>用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方 </p><p>式，且适用于任意组件间通信。</p><p>2.官网：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></p></blockquote><h3 id="二、什么时候使用Vuex"><a href="#二、什么时候使用Vuex" class="headerlink" title="二、什么时候使用Vuex"></a>二、什么时候使用Vuex</h3><blockquote><p>1.多个组件依赖于同一状态 </p><p>2.来自不同组件的行为需要变更同一状态</p></blockquote><h3 id="三、Vuex工作原理图"><a href="#三、Vuex工作原理图" class="headerlink" title="三、Vuex工作原理图"></a>三、Vuex工作原理图</h3><p><img src="E:\vue笔记资料\代码资料\资料（含课件）\02_原理图\vuex.png" alt="vuex"></p><h4 id="理解一"><a href="#理解一" class="headerlink" title="理解一"></a>理解一</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在组件中调用dispatch()</span></span><br><span class="line"><span class="number">1</span>、<span class="title function_">dispatch</span>(<span class="string">&#x27;add&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：在组件中也可以直接调用commit()，直接对接mutations</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>、</span><br><span class="line"><span class="keyword">let</span> actions = &#123;</span><br><span class="line"><span class="title function_">add</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line"><span class="comment">//提交</span></span><br><span class="line">context.<span class="title function_">commit</span>(<span class="string">&#x27;add&#x27;</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>、<span class="comment">//真正操作数据的是Mutations</span></span><br><span class="line"><span class="keyword">let</span> mutations = &#123;</span><br><span class="line"><span class="title function_">ADD</span>(<span class="params">state,<span class="number">2</span></span>)&#123;</span><br><span class="line">state.<span class="property">sum</span> += <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>、state中数据改变，重新渲染组件</span><br></pre></td></tr></table></figure><h4 id="理解二"><a href="#理解二" class="headerlink" title="理解二"></a>理解二</h4><p>Vue Component （客人）、Actions （ 服务员）、Mutations（ 后厨）、State（ 菜）</p><blockquote><ol><li>客人（Vue Component）进门张嘴说话（dispatch()），蛋炒饭一份（dispatch(‘蛋炒饭’,1)），</li><li>服务员（Actions）在点餐软件上下单交给（commit(‘蛋炒饭’,1)）后厨(Mutations)团队，</li><li>后厨收到加工成一份蛋炒饭(State)，</li><li>最后菜上桌给客人(Vue Component)。</li></ol></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>1.Vuex由 Actions、Mutations、State三部分组成，全部都由store管理。</p><p>2.dispatch()、commit()都由store提供</p><p>3.如何在任何一个组件中都能够调用dispatch()、调用commit()，由于都由store提供，因此要让所有的组件实例都能够使用store即可。</p></blockquote><h3 id="四、搭建Vuex环境"><a href="#四、搭建Vuex环境" class="headerlink" title="四、搭建Vuex环境"></a>四、搭建Vuex环境</h3><ol><li>安装vuex</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i vuex</span><br></pre></td></tr></table></figure><ol start="2"><li>在src文件夹中新建src&#x2F;store&#x2F;index.js</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该文件用于创建Vuex中最为核心的store</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions，用于响应组件中的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;;</span><br><span class="line"><span class="comment">//准备mutations，用于操作数据（data）</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;;</span><br><span class="line"><span class="comment">//准备state,用于存储数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123; <span class="attr">sum</span>: <span class="number">0</span>,&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建store,管理actions、mutations、state</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><ol start="3"><li>在main.js中创建vm时传入store配置项，让所有的组件实例能看见store</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入插件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">    store</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="五、Vuex基本使用"><a href="#五、Vuex基本使用" class="headerlink" title="五、Vuex基本使用"></a>五、Vuex基本使用</h3><p>1.初始化数据、配置actions、配置mutations、操作文件store&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引入Vue</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions，用于响应组件中的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">     <span class="title function_">add</span>(<span class="params">context, value</span>) &#123;</span><br><span class="line">         <span class="comment">// console.log(&#x27;add方法被调用&#x27;);</span></span><br><span class="line">         <span class="comment">//console.log(context, value);</span></span><br><span class="line">         context.<span class="title function_">commit</span>(<span class="string">&#x27;ADD&#x27;</span>, value);</span><br><span class="line">     &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//准备mutations，用于操作数据（data）</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="title function_">ADD</span>(<span class="params">state, value</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(&#x27;ADD方法被调用&#x27;);</span></span><br><span class="line">        <span class="comment">// console.log(state, value);</span></span><br><span class="line">        state.<span class="property">sum</span> += value;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//准备state,用于存储数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    <span class="attr">sum</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建store</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutation,</span><br><span class="line">    state</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><p>2.组件中读取Vuex中的数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$store.<span class="property">state</span>.<span class="property">sum</span></span><br></pre></td></tr></table></figure><p>3.组件中修改Vuex中的数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$store.<span class="title function_">dispatch</span>(<span class="string">&#x27;actions中的方法名&#x27;</span>,数据)</span><br><span class="line">或者</span><br><span class="line">$store.<span class="title function_">commit</span>(<span class="string">&#x27;mutations中的方法名&#x27;</span>,数据)</span><br></pre></td></tr></table></figure><p>注意：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch,直接编写commit</p><h3 id="六、getters的使用"><a href="#六、getters的使用" class="headerlink" title="六、getters的使用"></a>六、getters的使用</h3><p>目前，Vuex中有3个核心配置项，包括actions、mutations和state。除此外还有getters</p><p>1.概念：当state中的数据需要经过加工后再使用时，可以使用getters加工</p><p>2.在src&#x2F;store&#x2F;index.js中追加getters配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准备getters，将state中的数据进行加工</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">   .....</span><br><span class="line">    <span class="comment">//配置</span></span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.在组件中读取数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;$store.<span class="property">getters</span>.<span class="property">bigSum</span>&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="七、四个map方法的使用"><a href="#七、四个map方法的使用" class="headerlink" title="七、四个map方法的使用"></a>七、四个map方法的使用</h3><p>(1)程序员自己写计算属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">       sum()&#123; return this.$store.state.sum &#125;,</span><br><span class="line">       school()&#123; return this.$store.state.school &#125;,</span><br><span class="line">       subject()&#123; return this.$store.state.subject &#125;,</span><br><span class="line">    </span><br><span class="line">       bigSum()&#123; return this.$store.getters.bigSum &#125;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>(1.1)mapState()方法：用于帮助我们映射state中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">      <span class="comment">//借助mapState生成计算属性，从state中读取数据。（对象写法）</span></span><br><span class="line">     <span class="comment">// key是计算属性名，value是state中数据名</span></span><br><span class="line">       ...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">      <span class="comment">//借助mapState生成计算属性，从state中读取数据。（数组写法）</span></span><br><span class="line">      <span class="comment">//当key和value相同时，可以简写，记得加单引号</span></span><br><span class="line">      <span class="comment">//此时，sum表示计算属性名，也表示state中的数据sum</span></span><br><span class="line">      ...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>(1.2)mapGetters()方法：用于帮助我们映射getters中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">      <span class="comment">//借助mapGetters生成计算属性，从getters中读取数据。（对象写法）</span></span><br><span class="line">      ...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">       <span class="comment">//借助mapGetters生成计算属性，从getters中读取数据。（数组写法）</span></span><br><span class="line">       ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>]),</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>（2）如何优化以下代码？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">     <span class="title function_">increment</span>(<span class="params"></span>)&#123;<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;ADD&#x27;</span>,<span class="variable language_">this</span>.<span class="property">n</span>);&#125;,</span><br><span class="line">     <span class="title function_">decrement</span>(<span class="params"></span>)&#123;<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;SUBTRACT&#x27;</span>,<span class="variable language_">this</span>.<span class="property">n</span>);&#125;,</span><br><span class="line">     <span class="title function_">decrement</span>(<span class="params">value</span>)&#123;<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;SUBTRACT&#x27;</span>,value);&#125;,</span><br><span class="line">    </span><br><span class="line"> <span class="title function_">incrementOdd</span>(<span class="params"></span>)&#123;<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;addOdd&#x27;</span>,<span class="variable language_">this</span>.<span class="property">n</span>);&#125;,</span><br><span class="line">     <span class="title function_">incrementWait</span>(<span class="params"></span>)&#123;<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;addWait&#x27;</span>,<span class="variable language_">this</span>.<span class="property">n</span>);&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>(2.1)mapActions()方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapMutations,mapActions&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;  </span><br><span class="line">    <span class="comment">//借助mapActions生成incrementOdd、incrementWait(对象形式),方法中对调用dispatch()联系actions</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;addOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;addWait&#x27;</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//借助mapActions生成incrementOdd、incrementWait(数组形式)</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;addOdd&#x27;</span>,<span class="string">&#x27;addWait&#x27;</span>])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>(2.2)mapMutations()方法：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;increment(n)&quot;</span>&gt;+&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;mapMutations,mapActions&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;  </span><br><span class="line">    <span class="comment">//借助mapMutations生成increment、decrement(对象形式)，方法中对调用commit()联系mutations</span></span><br><span class="line">    <span class="comment">//key是方法名，value是动作类型</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;ADD&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;SUBTRACT&#x27;</span>&#125;),</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//借助mapMutations生成increment、decrement(数组形式)</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;ADD&#x27;</span>,<span class="string">&#x27;SUBTRACT&#x27;</span>]),</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>备注：mapActions与mapMutations使用时，若需要传递参数，在模板中绑定事件时传递好参数，否则参数是事件对象。</p><h3 id="八、Vuex模块化-命名空间"><a href="#八、Vuex模块化-命名空间" class="headerlink" title="八、Vuex模块化+命名空间"></a>八、Vuex模块化+命名空间</h3><p>1.目的：让代码更好维护，让多种数据分类更加明确</p><p>2.修改src&#x2F;store&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line"><span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line"><span class="attr">state</span>:&#123;...&#125;,</span><br><span class="line"><span class="attr">mutstaions</span>:&#123;...&#125;,</span><br><span class="line"><span class="attr">actions</span>:&#123;...&#125;,</span><br><span class="line"><span class="attr">getters</span>:&#123;</span><br><span class="line"><span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> state.<span class="property">sum</span> *<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line"><span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line"><span class="attr">state</span>:&#123;...&#125;,</span><br><span class="line"><span class="attr">mutaions</span>:&#123;...&#125;,</span><br><span class="line"><span class="attr">actions</span>:&#123;...&#125;,</span><br><span class="line"><span class="attr">getters</span>:&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">             </span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="comment">//配置项</span></span><br><span class="line"> <span class="attr">modules</span>:&#123;</span><br><span class="line">         countAbout,</span><br><span class="line">         personAbout</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.开启命名空间后，组件中读取state数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二：借助mapState读取</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>])</span><br></pre></td></tr></table></figure><p>4.开启命名空间后，组件中读取getters中数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure><p>5.开启命名空间后，组件中调用dispatch</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapActions</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;ADDODD&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;ADDWAIT&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>6.开启命名空间后，组件中调用commit</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapMutations读取</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;ADD&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;SUBTRACT&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/09/Vue-%E6%A8%A1%E6%9D%BF%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/09/09/Vue-%E6%A8%A1%E6%9D%BF%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>title: Vue模板指令<br>date: 2022-09-10 00:10:14<br>tags:vue</p><h3 id="Vue模板语法"><a href="#Vue模板语法" class="headerlink" title="Vue模板语法"></a>Vue模板语法</h3><p>vue模板中 中包含了一些vue 语法，语法分为两种，分别为： </p><ol><li>插值语法（双大括号表达式） </li><li>指令语法（以 v-开头）</li></ol><h4 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h4><ol><li><p><code>&#123;&#123;&#125;&#125;</code>，也叫Mustache语法，小胡子语法，因为长得像胡子</p></li><li><p>作用：用于解析标签体内容。</p></li><li><p>写法：，xxx是js表达式，且可以直接读取到data中的所有属性。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>插值语法<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>你好，&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"><span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">name</span>:<span class="string">&#x27;jack&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="el与data的两种写法"><a href="#el与data的两种写法" class="headerlink" title="el与data的两种写法"></a>el与data的两种写法</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>插值语法<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>你好，&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> v=<span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//el:&#x27;#root&#x27;, 第一中el写法</span></span></span><br><span class="line"><span class="language-javascript"><span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">name</span>:<span class="string">&#x27;jack&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v)</span></span><br><span class="line"><span class="language-javascript">    v.$mount(<span class="string">&#x27;#root&#x27;</span>)<span class="comment">//第二种el写法</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//date两种写法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> v=<span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//第一种：对象式</span></span></span><br><span class="line"><span class="language-javascript"><span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">name</span>:<span class="string">&#x27;jack&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript">   </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> v=<span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//第二种：函数式</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                   <span class="attr">name</span>:<span class="string">&#x27;jack&#x27;</span>, </span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h4><ul><li><p>解释：指令 (Directives) 是带有 <code>v-</code> 前缀的特殊属性，可以在html标签中使用，可以看成特殊的html属性</p></li><li><p>作用：指令提供了一些特殊的功能，当指向绑定到标签上时，可以给标签增加一些特殊的行为</p><p>vue指令按照不同的用途可以分为如下6大类：</p><ul><li>内容渲染指令：v-text、v-html、<code>&#123;&#123;&#125;&#125;</code></li><li>属性绑定指令：v-bind</li><li>事件绑定指令：v-on</li><li>双向绑定指令：v-model</li><li>条件渲染指令：v-show、v-if</li><li>列表渲染指令：v-for</li></ul></li></ul><h5 id="v-bind指令"><a href="#v-bind指令" class="headerlink" title="v-bind指令"></a>v-bind指令</h5><ol><li><p>作用：用于访问data中的数据，在标签的属性中使用</p></li><li><p>语法：v-bind:href &#x3D;”xxx” 或简写为 :href </p></li><li><p>特点：单向数据绑定，数据只能从 data 流向页面 </p></li><li><p>注意点：</p><ul><li><p>v-bind访问的值必须在data中存在</p></li><li><p>在使用 v-bind 属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号，例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:title</span>=<span class="string">&quot;&#x27;box&#x27; + index&quot;</span>&gt;</span>这是一个 div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 普通写法 --&gt;</span></span><br><span class="line">单向数据绑定：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"><span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">name</span>:<span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="v-text指令"><a href="#v-text指令" class="headerlink" title="v-text指令"></a>v-text指令</h5><ul><li>解释：v-text指令 会覆盖元素内部原有的内容。在实际开发中<code>&#123;&#123;&#125;&#125;</code>插值表达式用的最多，只是内容的占位符，不会覆盖原有的内容！</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="v-html指令"><a href="#v-html指令" class="headerlink" title="v-html指令"></a>v-html指令</h5><ul><li><p>作用：可以把带有标签的字符串，渲染成真正的HTML内容</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-html</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h5><ol><li>作用：双向数据绑定，数据不仅能从 data 流向页面，还能从页面流向 data</li><li>语法：v-mode:value&#x3D;”xxx” 或简写为 v-model&#x3D;”xxx” </li><li>注意：v-model只能用于表单元素上（比如 input、select、textarea）</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 准备好一个容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 普通写法 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 单向数据绑定：&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="comment">双向数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;br/&gt; --&gt;</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">&lt;!-- 简写 --&gt;</span></span><br><span class="line">单向数据绑定：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">双向数据绑定：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如下代码是错误的，因为v-model只能应用在表单类元素（输入类元素）上 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;h2 v-model:x=&quot;name&quot;&gt;你好啊&lt;/h2&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"><span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">name</span>:<span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="v-on指令"><a href="#v-on指令" class="headerlink" title="v-on指令"></a>v-on指令</h5><ul><li>作用：绑定事件</li><li>语法：<code>v-on:click=&quot;say&quot;</code> or <code>v-on:click=&quot;say(&#39;参数&#39;, $event)&quot;</code></li><li>简写：<code>@click=&quot;say&quot;</code></li><li>说明：绑定的事件从<code>methods</code>中获取</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>$event</code> 的应用场景：如果默认的事件对象 e 被覆盖了，则可以手动传递一个  $event。例如：</li></ul><h6 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h6><p>​        修饰符可以连续写</p><ul><li><code>.stop</code>       阻止冒泡，调用 event.stopPropagation()</li><li><strong><code>.prevent</code></strong>    阻止默认行为，调用 event.preventDefault()</li><li><code>.capture</code>    添加事件侦听器时使用事件<code>捕获</code>模式</li><li><code>.self</code>       只当事件在该元素本身（比如不是子元素）触发时，才会触发事件</li><li><code>.once</code>       事件只触发一次</li><li><code>.passive</code>  事件的默认行为立即执行，无需等待事件回调执行完毕</li></ul><h6 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h6><p>在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 <code>v-on</code> 在监听键盘事件keyup、keydown时添加按键修饰符： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Vue中常用的按键别名：</span><br><span class="line">.enter</span><br><span class="line">.tab （特殊，必须配合keydown去使用）</span><br><span class="line">.delete (捕获“删除”和“退格”键)</span><br><span class="line">.esc</span><br><span class="line">.space</span><br><span class="line">.up</span><br><span class="line">.down</span><br><span class="line">.left</span><br><span class="line">.right</span><br><span class="line"></span><br><span class="line">2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</span><br><span class="line"></span><br><span class="line">3.系统修饰键（用法特殊）：ctrl、alt、shift、meta</span><br><span class="line">(1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</span><br><span class="line">(2).配合keydown使用：正常触发事件。</span><br><span class="line"></span><br><span class="line">4.也可以使用keyCode去指定具体的按键（不推荐）</span><br><span class="line"></span><br><span class="line">5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名</span><br></pre></td></tr></table></figure><h5 id="v-show和v-if指令"><a href="#v-show和v-if指令" class="headerlink" title="v-show和v-if指令"></a>v-show和v-if指令</h5><ul><li><p><a href="https://cn.vuejs.org/v2/guide/conditional.html">条件渲染</a></p></li><li><p>v-if: 每次动态创建或移除元素，实现元素的显示和隐藏</p><ul><li>如果刚进入页面的时候，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时 v-if 性能更好</li></ul></li><li><p>v-show原理：动态为元素添加或移除 <code>display: none</code> 样式，来实现元素的显示和隐藏</p><ul><li>如果要频繁的切换元素的显示状态，用 v-show 性能会更好</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1.直接给定一个布尔值 true 或 false</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;true&quot;</span>&gt;</span>这个元素展示出来了吗？？？<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2.提供一个判断条件，根据判断的结果是 true 或 false，来控制元素的显示和隐藏</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;type === A&quot;</span>&gt;</span>这个元素，在HTML结构中吗？？？<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="v-for指令"><a href="#v-for指令" class="headerlink" title="v-for指令"></a>v-for指令</h5><ul><li>作用：基于源数据多次渲染元素或模板块，用于遍历一个数组或者一个对象</li><li>语法：v-for是一个属性，v-for指令谁需要重复的渲染，就给谁加<ul><li>v-for &#x3D; “item in 数组” item表示每次遍历出来的值，item的名字可以随意取</li><li>v-for &#x3D; “(item,index) in 数组” item表示值，index表示下标 </li><li>v-for&#x3D;”value in 对象”    </li><li>v-for&#x3D;”(value,key) in 对象”</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>pp的爱好<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in hobby&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in hobby&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;----&#123;&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;index in hobby&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(v,k) in girlFriend&quot;</span>&gt;</span>&#123;&#123;k&#125;&#125;-----&#123;&#123;v&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="key属性作用"><a href="#key属性作用" class="headerlink" title="key属性作用"></a>key属性作用</h6><ul><li>推荐：使用 <code>v-for</code> 的时候提供 <code>key</code> 属性，能够提升列表渲染的性能</li><li>说明：使用 key，VUE会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</li><li><a href="https://cn.vuejs.org/v2/guide/list.html#key">vue key</a></li><li><a href="https://www.zhihu.com/question/61064119/answer/183717717">vue key属性的说明</a></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="v-if、v-else、v-else-if"><a href="#v-if、v-else、v-else-if" class="headerlink" title="v-if、v-else、v-else-if"></a>v-if、v-else、v-else-if</h5><p>注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p><p>备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</p><p> v-if与template的配合使用（结构不会被破坏）</p><template v-if="n === 1">                <h2>你好</h2>                <h2>尚硅谷</h2>                <h2>北京</h2>            </template><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type == &#x27;A&#x27;&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type == &#x27;B&#x27;&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type == &#x27;C&#x27;&quot;</span>&gt;</span>一般<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>差<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: <span class="string">&#x27;A&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="v-cloak指令（没有值）"><a href="#v-cloak指令（没有值）" class="headerlink" title="v-cloak指令（没有值）"></a>v-cloak指令（没有值）</h5><p>​1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。<br>​2.使用css配合v-cloak可以解决网速慢时页面展示出的问题。</p><h5 id="v-once指令："><a href="#v-once指令：" class="headerlink" title="v-once指令："></a>v-once指令：</h5><p>​1.v-once所在节点在初次动态渲染后，就视为静态内容了。<br>​2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-once</span>&gt;</span>初始化的值是&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前的值是&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;n++&quot;</span>&gt;</span>点我n+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> vm= <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">             <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">n</span>:<span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">             &#125;,</span></span><br><span class="line"><span class="language-javascript">         &#125;)</span></span><br><span class="line"><span class="language-javascript">     </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="v-pre指令："><a href="#v-pre指令：" class="headerlink" title="v-pre指令："></a>v-pre指令：</h5><p>​1.跳过其所在节点的编译过程。<br>​2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-pre</span>&gt;</span>啦啦啦啦啦啦<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前的值是&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;n++&quot;</span>&gt;</span>点我n+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> vm= <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">             <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">n</span>:<span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">             &#125;,</span></span><br><span class="line"><span class="language-javascript">         &#125;)</span></span><br><span class="line"><span class="language-javascript">     </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h4><p>​          若：<input type="text"/>，则v-model收集的是value值，用户输入的就是value值。</p><p>​          若：<input type="radio"/>，则v-model收集的是value值，且要给标签配置value值。</p><p>​          若：<input type="checkbox"/></p><p>​              1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p><p>​              2.配置input的value属性:</p><p>​                  (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p><p>​                  (2)v-model的初始值是数组，那么收集的的就是value组成的数组</p><p>​          备注：v-model的三个修饰符：</p><p>​                  lazy：失去焦点再收集数据</p><p>​                  number：输入字符串转为有效的数字</p><p>​                  trim：输入首尾空格过滤</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>​        定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p><p>​        语法：</p><p>​            1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}</p><p>​            2.使用过滤器：<code>&#123;&#123; xxx | 过滤器名&#125;&#125;</code>  或<code>  v-bind:属性 = &quot;xxx | 过滤器名&quot;</code></p><p>​        备注：</p><p>​            1.过滤器也可以接收额外参数、多个过滤器也可以串联</p><p>​            2.并没有改变原本的数据, 是产生新的对应的数据</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>显示格式化后的时间<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 过滤器实现 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>现在是：&#123;&#123;time | timeFormater&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 过滤器实现(传参) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>现在是：&#123;&#123;time | timeFormater(&#x27;YYYY-MM-DD&#x27;) | mySlice&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">:x</span>=<span class="string">&quot;msg | mySlice&quot;</span>&gt;</span>sss<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 全局过滤器</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;mySlice&#x27;</span>,<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> value.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">4</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> vm= <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="attr">time</span>:<span class="number">1655298794249</span>,<span class="comment">//时间戳</span></span></span><br><span class="line"><span class="language-javascript">           <span class="attr">msg</span>:<span class="string">&#x27;nihhhhhh&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//    局部过滤器</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">filters</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">timeFormater</span>(<span class="params">value,str=<span class="string">&quot;YYYY年MM月DD日 HH:mm:ss&quot;</span></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;@&#x27;</span>,value);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span> <span class="title function_">dayjs</span>(value).<span class="title function_">format</span>(str)</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br></pre></td></tr></table></figure><h3 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h3><p>虽然没有完全遵循 <a href="https://zh.wikipedia.org/wiki/MVVM">MVVM 模型</a>，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 <code>vm</code> (ViewModel 的缩写) 这个变量名表示 Vue 实例。</p><ol><li><p>M：模型(Model) ：对应 data 中的数据 </p></li><li><p>V：视图(View) ：模板 </p></li><li><p>VM：视图模型(ViewModel) ： Vue 实例对象</p><p><a href="https://www.cnblogs.com/ZXH-null/p/13914181.html">MVVM</a></p></li></ol><blockquote><p><strong>总结：</strong></p><p><em>1.data中所有的属性，最后都出现在了vm身上。</em>(数据代理)</p><p><em>2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</em></p></blockquote><p>视频资源：<a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=11">数据代理</a></p><h3 id="class与style绑定"><a href="#class与style绑定" class="headerlink" title="class与style绑定"></a>class与style绑定</h3><ul><li><p>使用方式：<code>v-bind:class=&quot;expression&quot;</code> or <code>:class=&quot;expression&quot;</code></p></li><li><p>表达式的类型：字符串、数组、对象（重点）</p></li><li><p>语法：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> &#123;<span class="attribute">width</span>: <span class="number">100px</span>;<span class="attribute">height</span>: <span class="number">100px</span>;<span class="attribute">background-color</span>: red;&#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.fz</span> &#123;<span class="attribute">font-size</span>: <span class="number">40px</span>;&#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.green</span> &#123;<span class="attribute">background-color</span>: green;&#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    v-bind可以操作class属性和style属性的</span></span><br><span class="line"><span class="comment">    默认情况下，class属性 style属性都是字符串</span></span><br><span class="line"><span class="comment">    v-bind对于class属性和style属性增强了。允许class和style的值是对象  也可以是数组</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;fz: isFz, green: isGreen&#125;&quot;</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;obj&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 操作style --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;width: width&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">msg</span>: <span class="string">&#x27;hello vue&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">isFz</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">isGreen</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">obj</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">fz</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">green</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">width</span>: <span class="string">&#x27;200px&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><h4 id="计算属性基本用法"><a href="#计算属性基本用法" class="headerlink" title="计算属性基本用法"></a>计算属性基本用法</h4><blockquote><pre><code>   1. 计算属性写到computed属性中   2. 计算属性写法上是一个函数，计算属性实质上是一个属性，对应的函数的返回值。   3. 计算属性只会算一次，就会把结果存储起来，非常的高效   4. 计算属性只有当依赖的数据发生了改变，就会重新计算</code></pre><ol start="5"><li>什么时候使用计算属性：需要在插值表达式或者指令中书写复杂的逻辑，都应该由计算属性来提供</li></ol></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">      计算属性： computed</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 需求：需要显示msg的翻转后的一个结果 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; reverseMsg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; reverseMsg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; reverseMsg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 1. 缺点1：插值表达式中写了大量的逻辑判断，不好维护</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// computed: 指定计算属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">msg</span>: <span class="string">&#x27;中国人&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">reverseMsg</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我执行了&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">msg</span>.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="计算属性的完整形态"><a href="#计算属性的完整形态" class="headerlink" title="计算属性的完整形态"></a>计算属性的完整形态</h4><blockquote><p>1.计算属性默认情况只提供了get，只能获取</p><p>2.计算属性默认不能修改，非要修改，比如v-model绑定的是一个计算属性，必须用到计算属性的完整形态，提供 set (set的逻辑需要自己提供)</p></blockquote><p><a href="https://cn.vuejs.org/v2/guide/computed.html">计算属性完整形态</a></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入你的姓&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span> + </span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入你的名&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span>&gt;</span> =</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;你的名字是&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fullName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">lastName</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">firstName</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 计算属性的完整形态；如果需要修改计算属性的值，如果需要对计算属性使用双向绑定</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 默认提供的仅仅是getter, 当访问计算属性</span></span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// fullName: function () &#123;</span></span></span><br><span class="line"><span class="language-javascript">          <span class="comment">//   return this.lastName + &#x27; &#x27; + this.firstName</span></span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">          <span class="attr">fullName</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">lastName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">firstName</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="comment">// value修改的全名</span></span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">this</span>.<span class="property">lastName</span> = value.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">this</span>.<span class="property">firstName</span> = value.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>]</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="监听属性"><a href="#监听属性" class="headerlink" title="监听属性"></a>监听属性</h3><blockquote><p>vue实例中提供了一个watch属性，用于监听vue实例中的属性的变化。</p><p>watch对应了一个对象，键是观察的属性，值是对应的回调函数。</p></blockquote><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ul><li><p>基本使用</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">//第一个参数：当前值</span><br><span class="line">   //第二个参数：上一次的值</span><br><span class="line">   username: function(curr, old) &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表单校验效果</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// watch: 监视数据的变化</span><br><span class="line">watch: &#123;</span><br><span class="line">    // 监视msg，只要msg属性的值发生改变，function就会执行</span><br><span class="line">    // value: 当前值  oldValue:上一次的值</span><br><span class="line">    msg: function(value) &#123;</span><br><span class="line">        if (value.length &gt;=3 &amp;&amp; value.length &lt;= 6) &#123;</span><br><span class="line">            this.tips = &#x27;正确&#x27;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.tips = &#x27;密码格式不正确&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="监视对象"><a href="#监视对象" class="headerlink" title="监视对象"></a>监视对象</h4><blockquote><p>监视对象的时候，需要加上<code>deep: true</code></p><p>为了发现对象内部值的变化，可以在选项参数中指定 <code>deep: true</code> </p></blockquote></li><li><p>如果是一个对象，无法监听到对象内部值的变化</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">user</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">age</span>: <span class="number">18</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">watch</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">user</span>: <span class="keyword">function</span>(<span class="params">curr, old</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(curr, old);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;user.name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;user.age&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>需要加上deep</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">        <span class="comment">// 监视多级结构中的所有属性的变化</span></span><br><span class="line">            <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">handler</span>: <span class="keyword">function</span>(<span class="params">curr, old</span>) &#123;</span><br><span class="line">                <span class="comment">//注意：如果监听的是对象，新值与旧值都是相同的，因为指向了同一个对象。</span></span><br><span class="line">                <span class="comment">//https://cn.vuejs.org/v2/api/#vm-watch</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(curr.<span class="property">age</span>, curr.<span class="property">name</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>immediate</strong> 属性,立马进行监听</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">        <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">immediate</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">handler</span>: <span class="keyword">function</span>(<span class="params">curr, old</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(curr.<span class="property">age</span>, curr.<span class="property">name</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="computed和watch之间的区别："><a href="#computed和watch之间的区别：" class="headerlink" title="computed和watch之间的区别："></a>computed和watch之间的区别：</h3><p>1.computed能完成的功能，watch都可以完成。<br>2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</p><p>两个重要的小原则：<br>                                1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。<br>                                2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，<br>    这样this的指向才是vm 或 组件实例对象。</p><h3 id="Vue监听数据原理"><a href="#Vue监听数据原理" class="headerlink" title="Vue监听数据原理"></a>Vue监听数据原理</h3><pre><code>Vue监视数据的原理：            1. vue会监视data中所有层次的数据。            2. 如何监测对象中的数据？            通过setter实现监视，且要在new Vue时就传入要监测的数据。                (1).对象中后追加的属性，Vue默认不做响应式处理                (2).如需给后添加的属性做响应式，请使用如下API：                    Vue.set(target，propertyName/index，value) 或                     vm.$set(target，propertyName/index，value)            3. 如何监测数组中的数据？            通过包裹数组更新元素的方法实现，本质就是做了两件事：                (1).调用原生对应的方法对数组进行更新。                (2).重新解析模板，进而更新页面。            4.在Vue修改数组中的某个元素一定要用如下方法：               1.使用这些API:               push()、pop()、shift()、unshift()、splice()、sort()、reverse()                              2.Vue.set() 或 vm.$set()                        特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</code></pre><h3 id="案例：TodoMVC"><a href="#案例：TodoMVC" class="headerlink" title="案例：TodoMVC"></a>案例：TodoMVC</h3><p><a href="https://todomvc.com/examples/vue/">todomvc</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/09/09/Vue2%E5%88%B0Vue3%E7%9A%84%E5%8F%98%E5%8C%96/"/>
      <url>/2022/09/09/Vue2%E5%88%B0Vue3%E7%9A%84%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>title: Vue3<br>date: 2022-09-10 00:10:14<br>tags:vue</p><h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" /><h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul><li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li><li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li><li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>……</p></li></ul><h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>……</p></li></ul><h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment </li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue --version</span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">## 创建</span></span><br><span class="line">vue create vue_test</span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li>什么是vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite构建对比图</li></ul><p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在setup中。</li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与Vue2.x配置混用<ul><li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code> <ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li><li>JS中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    get () &#123;&#125;, </span><br><span class="line">    set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul><li>实现原理: <ul><li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li><li>通过Reflect（反射）:  对源对象的属性进行操作。</li><li>MDN文档中描述的Proxy与Reflect：<ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line"><span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul><li>从定义数据角度对比：<ul><li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul><li><p>setup执行的时机</p><ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li><p>setup的参数</p><ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.<span class="property">firstName</span> = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.<span class="property">lastName</span> = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul><li><p>与Vue2.x中watch配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性时（属性的值得是一个对象）：deep配置有效。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>([sum,msg],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>&#125;) <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">()=&gt;</span>person.<span class="property">name</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;) <span class="comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> x2 = person.<span class="property">age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><div style="border:1px solid black;width:300px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="https://v2.cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:480px;height:785px;float:left"><strong>vue3.0的生命周期</strong><img src="https://cn.vuejs.org/assets/lifecycle.16e4c08e.png" alt="lifecycle_2" style="zoom:33%;width:2500px" /></div><p>1.Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：</p><ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul><p>2.Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：</p><ul><li><code>beforeCreate</code>&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>created</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li><li><code>beforeMount</code> &#x3D;&#x3D;&#x3D;&gt;<code>onBeforeMount</code></li><li><code>mounted</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>&#x3D;&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> &#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUnmounted</code></li></ul><h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul><li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p></li><li><p>类似于vue2.x中的mixin。</p></li><li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p></li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p></li><li><p>语法：<code>const name = toRef(person,&#39;name&#39;)</code></p></li><li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p></li><li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code>   在return中写成 <code>...toRefs(person)</code>  使用扩展运算符</p></li></ul><h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul><li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p></li><li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p></li><li><p>什么时候使用?</p><ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li></ul></li></ul><h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>， <code>ref</code>不行。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;</span><br><span class="line">&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;ref,customRef&#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Demo&#x27;,</span><br><span class="line">setup()&#123;</span><br><span class="line">// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span><br><span class="line">//自定义一个myRef</span><br><span class="line">function myRef(value,delay)&#123;</span><br><span class="line">let timer</span><br><span class="line">//通过customRef去实现自定义</span><br><span class="line">return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">return&#123;</span><br><span class="line">get()&#123;</span><br><span class="line">track() //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">return value</span><br><span class="line">&#125;,</span><br><span class="line">set(newValue)&#123;</span><br><span class="line">clearTimeout(timer)</span><br><span class="line">timer = setTimeout(()=&gt;&#123;</span><br><span class="line">value = newValue</span><br><span class="line">trigger() //告诉Vue去更新界面</span><br><span class="line">&#125;,delay)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref</span><br><span class="line">return &#123;</span><br><span class="line">keyword</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" /><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后代组件中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div style="width:500px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" /></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> </div><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div style="width:400px;height:340px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><div style="width:400px;height:340px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;teleport to=&quot;移动位置&quot;&gt;</span><br><span class="line">&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">&lt;Suspense&gt;</span><br><span class="line">&lt;template v-slot:default&gt;</span><br><span class="line">&lt;Child/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-slot:fallback&gt;</span><br><span class="line">&lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Vue3.x写法</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#x27;close&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>……</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
